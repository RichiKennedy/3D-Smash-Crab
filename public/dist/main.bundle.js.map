{"version":3,"file":"dist/main.bundle.js","mappings":";;;;;;;;;AAAA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,aAKJ;AACF,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,8BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B,eAAe,8BAAmB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,8BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,8BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,iBAAiB,8BAAmB,CAAC,8BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,qGAAqG,qBAAqB,mBAAmB;;AAE7I,+BAAmB;AACnB,WAAW,+BAAmB;AAC9B,UAAU,+BAAmB;AAC7B,gBAAgB,+BAAmB;;AAEnC;AACA;AACA,kBAAkB;AAClB;AACA,cAAc;AACd,8BAA8B,YAAY;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;;AAEjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;;AAE5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,UAAU,gCAAmB;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,WAAW,iCAAiC;AAC5C,UAAU,gBAAgB;AAC1B,WAAW,gBAAgB;AAC3B,YAAY,YAAY;AACxB,gBAAgB,gBAAgB;AAChC,qBAAqB;AACrB,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qDAAqD;AACrD,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA,CAAC;;;;;;;;;;ACptCDA,MAAM,CAACC,iBAAP,CAAyB,cAAzB,EAAyC;EACvCC,IAAI,EAAE,gBAAY;IAChB,IAAIC,KAAK,GAAG,EAAZ;IAEA,KAAKC,EAAL,CAAQC,gBAAR,CAAyB,cAAzB,EAAyC,YAAY;MACnDF,KAAK,GAAGG,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,QAAQ,CAACC,gBAAT,CAA0B,OAA1B,CAA3B,CAAR;IACD,CAFD;IAGA,KAAKP,EAAL,CAAQC,gBAAR,CAAyB,gBAAzB,EAA2C,YAAY;MACrDF,KAAK,CAACS,GAAN,CAAU,UAAUC,IAAV,EAAgB;QACxBA,IAAI,CAACC,IAAL,CAAU,SAAV;MACD,CAFD;IAGD,CAJD;IAKA,KAAKV,EAAL,CAAQC,gBAAR,CAAyB,cAAzB,EAAyC,YAAY;MACnDF,KAAK,CAACS,GAAN,CAAU,UAAUC,IAAV,EAAgB;QACxBA,IAAI,CAACC,IAAL,CAAU,KAAV;MACD,CAFD;IAGD,CAJD;EAKD;AAjBsC,CAAzC;;;;;;;;;;;;;;ACAA;AACAd,MAAM,CAACe,aAAP,CAAqB;EACnBC,YAAY,EAAE;IACZC,KAAK,EAAE;EADK,CADK;EAKnBC,QAAQ,EAAE;IACRC,aAAa,EAAE,uBAAUC,KAAV,EAAiBC,MAAjB,EAAyB;MACtCD,KAAK,CAACH,KAAN,IAAeI,MAAM,CAACC,MAAtB;IACD,CAHO;IAKRC,aAAa,EAAE,uBAAUH,KAAV,EAAiBC,MAAjB,EAAyB;MACtCD,KAAK,CAACH,KAAN,IAAeI,MAAM,CAACC,MAAtB;IACD;EAPO;AALS,CAArB;;;;;;UCDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACNA;CAGA","sources":["webpack://3d-smash-crab/./node_modules/aframe-state-component/dist/aframe-state-component.js","webpack://3d-smash-crab/./js/components/hammer-logic.js","webpack://3d-smash-crab/./js/components/state.js","webpack://3d-smash-crab/webpack/bootstrap","webpack://3d-smash-crab/webpack/runtime/compat get default export","webpack://3d-smash-crab/webpack/runtime/define property getters","webpack://3d-smash-crab/webpack/runtime/hasOwnProperty shorthand","webpack://3d-smash-crab/webpack/runtime/make namespace object","webpack://3d-smash-crab/./js/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Pre-compiled functions.\nvar selectFunctions = {};\n\n/**\n * Select value from store. Handles boolean operations, calls `selectProperty`.\n *\n * @param {object} state - State object.\n * @param {string} selector - Dot-delimited store keys (e.g., game.player.health).\n * @param {object} item - From bind-item.\n */\nfunction select(state, selector, item) {\n  if (!selectFunctions[selector]) {\n    selectFunctions[selector] = new Function('state', 'item', 'return ' + generateExpression(selector) + ';');\n  }\n  return selectFunctions[selector](state, item);\n}\nmodule.exports.select = select;\n\nvar DOT_NOTATION_RE = /\\.([A-Za-z][\\w_-]*)/g;\nvar WHITESPACE_RE = /\\s/g;\nvar STATE_SELECTOR_RE = /([=&|!?:+-])(\\s*)([\\(]?)([A-Za-z][\\w_-]*)/g;\nvar ROOT_STATE_SELECTOR_RE = /^([\\(]?)([A-Za-z][\\w_-]*)/g;\nvar ITEM_RE = /state\\[\"item\"\\]/g;\nvar BOOLEAN_RE = /state\\[\"(true|false)\"\\]/g;\nvar STATE_STR = 'state';\nfunction generateExpression(str) {\n  str = str.replace(DOT_NOTATION_RE, '[\"$1\"]');\n  str = str.replace(ROOT_STATE_SELECTOR_RE, '$1state[\"$2\"]');\n  str = str.replace(STATE_SELECTOR_RE, '$1$2$3state[\"$4\"]');\n  str = str.replace(ITEM_RE, 'item');\n  str = str.replace(BOOLEAN_RE, '$1');\n  return str;\n}\nmodule.exports.generateExpression = generateExpression;\n\nfunction clearObject(obj) {\n  for (var key in obj) {\n    delete obj[key];\n  }\n}\nmodule.exports.clearObject = clearObject;\n\n/**\n * Helper to compose object of handlers, merging functions handling same action.\n */\nfunction composeHandlers() {\n  var actionName;\n  var i;\n  var inputHandlers = arguments;\n  var outputHandlers;\n\n  outputHandlers = {};\n  for (i = 0; i < inputHandlers.length; i++) {\n    for (actionName in inputHandlers[i]) {\n      if (actionName in outputHandlers) {\n        // Initial compose/merge functions into arrays.\n        if (outputHandlers[actionName].constructor === Array) {\n          outputHandlers[actionName].push(inputHandlers[i][actionName]);\n        } else {\n          outputHandlers[actionName] = [outputHandlers[actionName], inputHandlers[i][actionName]];\n        }\n      } else {\n        outputHandlers[actionName] = inputHandlers[i][actionName];\n      }\n    }\n  }\n\n  // Compose functions specified via array.\n  for (actionName in outputHandlers) {\n    if (outputHandlers[actionName].constructor === Array) {\n      outputHandlers[actionName] = composeFunctions.apply(this, outputHandlers[actionName]);\n    }\n  }\n\n  return outputHandlers;\n}\nmodule.exports.composeHandlers = composeHandlers;\n\nfunction composeFunctions() {\n  var functions = arguments;\n  return function () {\n    var i;\n    for (i = 0; i < functions.length; i++) {\n      functions[i].apply(this, arguments);\n    }\n  };\n}\nmodule.exports.composeFunctions = composeFunctions;\n\nvar NO_WATCH_TOKENS = ['||', '&&', '!=', '!==', '==', '===', '>', '<', '<=', '>='];\nvar WHITESPACE_PLUS_RE = /\\s+/;\nvar SYMBOLS = /\\(|\\)|\\!/g;\nfunction parseKeysToWatch(keys, str, isBindItem) {\n  var i;\n  var tokens;\n  tokens = split(str, WHITESPACE_PLUS_RE);\n  for (i = 0; i < tokens.length; i++) {\n    if (NO_WATCH_TOKENS.indexOf(tokens[i]) === -1 && !tokens[i].startsWith(\"'\") && keys.indexOf(tokens[i]) === -1) {\n      if (isBindItem && tokens[i] === 'item') {\n        continue;\n      }\n      keys.push(parseKeyToWatch(tokens[i]).replace(SYMBOLS, ''));\n    }\n  }\n  return keys;\n}\nmodule.exports.parseKeysToWatch = parseKeysToWatch;\n\nfunction parseKeyToWatch(str) {\n  var dotIndex;\n  str = stripNot(str.trim());\n  dotIndex = str.indexOf('.');\n  if (dotIndex === -1) {\n    return str;\n  }\n  return str.substring(0, str.indexOf('.'));\n}\n\nfunction stripNot(str) {\n  if (str.indexOf('!!') === 0) {\n    return str.replace('!!', '');\n  } else if (str.indexOf('!') === 0) {\n    return str.replace('!', '');\n  }\n  return str;\n}\n\n/**\n * Cached split.\n */\nvar SPLIT_CACHE = {};\nfunction split(str, delimiter) {\n  if (!SPLIT_CACHE[delimiter]) {\n    SPLIT_CACHE[delimiter] = {};\n  }\n  if (SPLIT_CACHE[delimiter][str]) {\n    return SPLIT_CACHE[delimiter][str];\n  }\n  SPLIT_CACHE[delimiter][str] = str.split(delimiter);\n  return SPLIT_CACHE[delimiter][str];\n}\nmodule.exports.split = split;\n\nfunction copyArray(dest, src) {\n  var i;\n  dest.length = 0;\n  for (i = 0; i < src.length; i++) {\n    dest[i] = src[i];\n  }\n}\nmodule.exports.copyArray = copyArray;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n__webpack_require__(2);\nvar diff = __webpack_require__(3);\nvar lib = __webpack_require__(0);\nvar wrapArray = __webpack_require__(4).wrapArray;\n\n// Singleton state definition.\nvar State = {\n  initialState: {},\n  nonBindedStateKeys: [],\n  handlers: {},\n  computeState: [function () {/* no-op */}]\n};\n\nvar STATE_UPDATE_EVENT = 'stateupdate';\nvar TYPE_OBJECT = 'object';\nvar WHITESPACE_REGEX = /s+/;\n\nAFRAME.registerState = function (definition) {\n  var computeState = State.computeState;\n  if (definition.computeState) {\n    computeState.push(definition.computeState);\n  }\n  AFRAME.utils.extendDeep(State, definition);\n  State.computeState = computeState;\n};\n\nAFRAME.registerSystem('state', {\n  init: function init() {\n    var _this = this;\n\n    var key;\n\n    this.arrays = [];\n    this.dirtyArrays = [];\n    this.diff = {};\n    this.state = AFRAME.utils.clone(State.initialState);\n    this.subscriptions = [];\n    this.initEventHandlers();\n\n    // Wrap array to detect dirty.\n    for (key in this.state) {\n      if (this.state[key] && this.state[key].constructor === Array) {\n        this.arrays.push(key);\n        this.state[key].__dirty = true;\n        wrapArray(this.state[key]);\n      }\n    }\n\n    this.lastState = AFRAME.utils.clone(this.state);\n\n    this.eventDetail = {\n      lastState: this.lastState,\n      state: this.state\n    };\n\n    this.el.addEventListener('loaded', function () {\n      var i;\n      // Initial compute.\n      for (i = 0; i < State.computeState.length; i++) {\n        State.computeState[i](_this.state, '@@INIT');\n      }\n      // Initial dispatch.\n      for (i = 0; i < _this.subscriptions.length; i++) {\n        _this.subscriptions[i].onStateUpdate(_this.state);\n      }\n    });\n  },\n\n  /**\n   * Dispatch action.\n   */\n  dispatch: function () {\n    var toUpdate = [];\n\n    return function (actionName, payload) {\n      var dirtyArrays;\n      var i;\n      var key;\n      var subscription;\n\n      // Modify state.\n      State.handlers[actionName](this.state, payload);\n\n      // Post-compute.\n      for (i = 0; i < State.computeState.length; i++) {\n        State.computeState[i](this.state, actionName, payload);\n      }\n\n      // Get a diff to optimize bind updates.\n      for (key in this.diff) {\n        delete this.diff[key];\n      }\n      diff(this.lastState, this.state, this.diff, State.nonBindedStateKeys);\n\n      this.dirtyArrays.length = 0;\n      for (i = 0; i < this.arrays.length; i++) {\n        if (this.state[this.arrays[i]].__dirty) {\n          this.dirtyArrays.push(this.arrays[i]);\n        }\n      }\n\n      // Notify subscriptions / binders.\n      toUpdate.length = 0;\n      for (i = 0; i < this.subscriptions.length; i++) {\n        if (this.subscriptions[i].name === 'bind-for') {\n          // For arrays and bind-for, check __dirty flag on array rather than the diff.\n          if (!this.state[this.subscriptions[i].keysToWatch[0]].__dirty) {\n            continue;\n          }\n        } else {\n          if (!this.shouldUpdate(this.subscriptions[i].keysToWatch, this.diff, this.dirtyArrays)) {\n            continue;\n          }\n        }\n\n        // Keep track to only update subscriptions once.\n        if (toUpdate.indexOf(this.subscriptions[i]) === -1) {\n          toUpdate.push(this.subscriptions[i]);\n        }\n      }\n\n      // Update subscriptions.\n      for (i = 0; i < toUpdate.length; i++) {\n        toUpdate[i].onStateUpdate();\n      }\n\n      // Unset array dirty.\n      for (key in this.state) {\n        if (this.state[key] && this.state[key].constructor === Array) {\n          this.state[key].__dirty = false;\n        }\n      }\n\n      // Store last state.\n      this.copyState(this.lastState, this.state);\n\n      // Emit.\n      this.eventDetail.action = actionName;\n      this.eventDetail.payload = payload;\n      this.el.emit(STATE_UPDATE_EVENT, this.eventDetail);\n    };\n  }(),\n\n  /**\n   * Store last state through a deep extend, but not for arrays.\n   */\n  copyState: function copyState(lastState, state, isRecursive) {\n    var key;\n\n    for (key in state) {\n      // Don't copy pieces of state keys that are non-binded or untracked.\n      if (!isRecursive && State.nonBindedStateKeys.indexOf(key) !== -1) {\n        continue;\n      }\n\n      // Nested state.\n      if (state[key] && state[key].constructor === Object) {\n        if (!(key in lastState)) {\n          // Clone object if destination does not exist.\n          lastState[key] = AFRAME.utils.clone(state[key]);\n          continue;\n        }\n        // Recursively copy state.\n        this.copyState(lastState[key], state[key], true);\n        continue;\n      }\n\n      // Copy by value.\n      lastState[key] = state[key];\n    }\n  },\n\n  subscribe: function subscribe(component) {\n    this.subscriptions.push(component);\n  },\n\n  unsubscribe: function unsubscribe(component) {\n    this.subscriptions.splice(this.subscriptions.indexOf(component), 1);\n  },\n\n  /**\n   * Check if state changes were relevant to this binding. If not, don't call.\n   */\n  shouldUpdate: function shouldUpdate(keysToWatch, diff, dirtyArrays) {\n    for (var i = 0; i < keysToWatch.length; i++) {\n      if (keysToWatch[i] in diff || dirtyArrays.indexOf(keysToWatch[i]) !== -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Proxy events to action dispatches so components can just bubble actions up as events.\n   * Handlers define which actions they handle. Go through all and add event listeners.\n   */\n  initEventHandlers: function initEventHandlers() {\n    var actionName;\n    var registeredActions = [];\n    var self = this;\n\n    registerListener = registerListener.bind(this);\n\n    // Use declared handlers to know what events to listen to.\n    for (actionName in State.handlers) {\n      // Only need to register one handler for each event.\n      if (registeredActions.indexOf(actionName) !== -1) {\n        continue;\n      }\n      registeredActions.push(actionName);\n      registerListener(actionName);\n    }\n\n    function registerListener(actionName) {\n      var _this2 = this;\n\n      this.el.addEventListener(actionName, function (evt) {\n        _this2.dispatch(actionName, evt.detail);\n      });\n    }\n  },\n\n  /**\n   * Render template to string with item data.\n   */\n  renderTemplate: function () {\n    // Braces, whitespace, optional item name, item key, whitespace, braces.\n    var interpRegex = /{{\\s*(\\w*\\.)?([\\w.]+)\\s*}}/g;\n\n    return function (template, data, asString) {\n      var match;\n      var str;\n\n      str = template;\n\n      // Data will be null if initialize pool for bind-for.updateInPlace.\n      if (data) {\n        while (match = interpRegex.exec(template)) {\n          str = str.replace(match[0], (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === TYPE_OBJECT ? lib.select(data, match[2]) || '' : data);\n        }\n      }\n\n      // Return as string.\n      if (asString) {\n        return str;\n      }\n\n      // Return as DOM.\n      return document.createRange().createContextualFragment(str);\n    };\n  }(),\n\n  select: lib.select\n});\n\n/**\n * Bind component property to a value in state.\n *\n * bind=\"geometry.width: car.width\"\"\n * bind__material=\"color: enemy.color; opacity: enemy.opacity\"\n * bind__visible=\"player.visible\"\n */\nAFRAME.registerComponent('bind', {\n  schema: {\n    default: {},\n    parse: function parse(value) {\n      // Parse style-like object.\n      var data;\n      var i;\n      var properties;\n      var pair;\n\n      // Using setAttribute with object, no need to parse.\n      if (value.constructor === Object) {\n        return value;\n      }\n\n      // Using instanced ID as component namespace for single-property component,\n      // nothing to separate.\n      if (value.indexOf(':') === -1) {\n        return value;\n      }\n\n      // Parse style-like object as keys to values.\n      data = {};\n      properties = lib.split(value, ';');\n      for (i = 0; i < properties.length; i++) {\n        pair = lib.split(properties[i].trim(), ':');\n        data[pair[0]] = pair[1].trim();\n      }\n      return data;\n    }\n  },\n\n  multiple: true,\n\n  init: function init() {\n    var componentId;\n    var data = this.data;\n    var key;\n\n    this.keysToWatch = [];\n    this.onStateUpdate = this.onStateUpdate.bind(this);\n    this.system = this.el.sceneEl.systems.state;\n\n    // Whether we are binding by namespace (e.g., bind__foo=\"prop1: true\").\n    if (this.id) {\n      componentId = lib.split(this.id, '__')[0];\n    }\n\n    this.isNamespacedBind = this.id && componentId in AFRAME.components && !AFRAME.components[componentId].isSingleProp || componentId in AFRAME.systems;\n\n    this.lastData = {};\n    this.updateObj = {};\n\n    // Subscribe to store and register handler to do data-binding to components.\n    this.system.subscribe(this);\n\n    this.onStateUpdate = this.onStateUpdate.bind(this);\n  },\n\n  update: function update() {\n    var data = this.data;\n    var key;\n    var property;\n\n    // Index `keysToWatch` to only update state on relevant changes.\n    this.keysToWatch.length = 0;\n    if (typeof data === 'string') {\n      lib.parseKeysToWatch(this.keysToWatch, data);\n    } else {\n      for (key in data) {\n        lib.parseKeysToWatch(this.keysToWatch, data[key]);\n      }\n    }\n\n    this.onStateUpdate();\n  },\n\n  /**\n   * Handle state update.\n   */\n  onStateUpdate: function onStateUpdate() {\n    // Update component with the state.\n    var hasKeys = false;\n    var el = this.el;\n    var propertyName;\n    var stateSelector;\n    var state;\n    var tempNode;\n    var value;\n\n    if (!el.parentNode) {\n      return;\n    }\n    if (this.isNamespacedBind) {\n      lib.clearObject(this.updateObj);\n    }\n\n    state = this.system.state;\n\n    // Single-property bind.\n    if (_typeof(this.data) !== TYPE_OBJECT) {\n      try {\n        value = lib.select(state, this.data);\n      } catch (e) {\n        throw new Error('[aframe-state-component] Key \\'' + this.data + '\\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));\n      }\n\n      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== TYPE_OBJECT && _typeof(this.lastData) !== TYPE_OBJECT && this.lastData === value) {\n        return;\n      }\n\n      AFRAME.utils.entity.setComponentProperty(el, this.id, value);\n      this.lastData = value;\n      return;\n    }\n\n    for (propertyName in this.data) {\n      // Pointer to a value in the state (e.g., `player.health`).\n      stateSelector = this.data[propertyName].trim();\n      try {\n        value = lib.select(state, stateSelector);\n      } catch (e) {\n        console.log(e);\n        throw new Error('[aframe-state-component] Key \\'' + stateSelector + '\\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));\n      }\n\n      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== TYPE_OBJECT && _typeof(this.lastData[propertyName]) !== TYPE_OBJECT && this.lastData[propertyName] === value) {\n        continue;\n      }\n\n      // Remove component if value is `undefined`.\n      if (propertyName in AFRAME.components && value === undefined) {\n        el.removeAttribute(propertyName);\n        return;\n      }\n\n      // Set using dot-delimited property name.\n      if (this.isNamespacedBind) {\n        // Batch if doing namespaced bind.\n        this.updateObj[propertyName] = value;\n      } else {\n        AFRAME.utils.entity.setComponentProperty(el, propertyName, value);\n      }\n\n      this.lastData[propertyName] = value;\n    }\n\n    // Batch if doing namespaced bind.\n    for (hasKeys in this.updateObj) {\n      // See if object is empty.\n    }\n    if (this.isNamespacedBind && hasKeys) {\n      el.setAttribute(this.id, this.updateObj);\n    }\n  },\n\n  remove: function remove() {\n    this.system.unsubscribe(this);\n  }\n});\n\n/**\n * Toggle component attach and detach based on boolean value.\n *\n * bind-toggle__raycastable=\"isRaycastable\"\"\n */\nAFRAME.registerComponent('bind-toggle', {\n  schema: { type: 'string' },\n\n  multiple: true,\n\n  init: function init() {\n    this.system = this.el.sceneEl.systems.state;\n    this.keysToWatch = [];\n    this.onStateUpdate = this.onStateUpdate.bind(this);\n\n    // Subscribe to store and register handler to do data-binding to components.\n    this.system.subscribe(this);\n\n    this.onStateUpdate();\n  },\n\n  update: function update() {\n    this.keysToWatch.length = 0;\n    lib.parseKeysToWatch(this.keysToWatch, this.data);\n  },\n\n  /**\n   * Handle state update.\n   */\n  onStateUpdate: function onStateUpdate() {\n    var el = this.el;\n    var state;\n    var value;\n\n    state = this.system.state;\n\n    try {\n      value = lib.select(state, this.data);\n    } catch (e) {\n      throw new Error('[aframe-state-component] Key \\'' + this.data + '\\' not found in state.' + (' #' + this.el.getAttribute('id') + '[' + this.attrName + ']'));\n    }\n\n    if (value) {\n      el.setAttribute(this.id, '');\n    } else {\n      el.removeAttribute(this.id);\n    }\n  },\n\n  remove: function remove() {\n    this.system.unsubscribe(this);\n  }\n});\n\nmodule.exports = {\n  composeFunctions: lib.composeFunctions,\n  composeHandlers: lib.composeHandlers,\n  select: lib.select\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar lib = __webpack_require__(0);\n\nvar ITEM_RE = /item/;\nvar ITEM_PREFIX_RE = /item./;\nvar ITEM_SELECTOR_RE = /item.(\\w+)/;\n\n/**\n * Render array from state.\n */\nAFRAME.registerComponent('bind-for', {\n  schema: {\n    delay: { default: 0 },\n    for: { type: 'string', default: 'item' },\n    in: { type: 'string' },\n    key: { type: 'string' },\n    pool: { default: 0 },\n    template: { type: 'string' },\n    updateInPlace: { default: false }\n  },\n\n  init: function init() {\n    // Subscribe to store and register handler to do data-binding to components.\n    this.system = this.el.sceneEl.systems.state;\n    this.onStateUpdate = this.onStateUpdate.bind(this);\n\n    this.keysToWatch = [];\n    this.renderedKeys = []; // Keys that are currently rendered.\n    this.system.subscribe(this);\n\n    if (this.el.children[0] && this.el.children[0].tagName === 'TEMPLATE') {\n      this.template = this.el.children[0].innerHTML.trim();\n    } else {\n      this.template = document.querySelector(this.data.template).innerHTML.trim();\n    }\n\n    for (var i = 0; i < this.data.pool; i++) {\n      this.el.appendChild(this.generateFromTemplate(null, i));\n    }\n  },\n\n  update: function update() {\n    this.keysToWatch[0] = lib.split(this.data.in, '.')[0];\n    this.onStateUpdate();\n  },\n\n  /**\n   * When items are swapped out, the old ones are removed, and new ones are added. All\n   * entities will be reinitialized.\n   */\n  onStateUpdateNaive: function () {\n    var activeKeys = [];\n\n    return function () {\n      var child;\n      var data = this.data;\n      var el = this.el;\n      var list;\n      var key;\n      var keyValue;\n\n      try {\n        list = lib.select(this.system.state, data.in);\n      } catch (e) {\n        throw new Error('[aframe-state-component] Key \\'' + data.in + '\\' not found in state.' + (' #' + el.getAttribute('id') + '[' + this.attrName + ']'));\n      }\n\n      activeKeys.length = 0;\n      for (var i = 0; i < list.length; i++) {\n        var item = list[i];\n        // If key not defined, use index (e.g., array of strings).\n        activeKeys.push(data.key ? item[data.key].toString() : item.toString());\n      }\n\n      // Remove items by removing entities.\n      var toRemoveEls = this.getElsToRemove(activeKeys, this.renderedKeys);\n      for (var _i = 0; _i < toRemoveEls.length; _i++) {\n        toRemoveEls[_i].parentNode.removeChild(toRemoveEls[_i]);\n      }\n\n      if (list.length) {\n        this.renderItems(list, activeKeys, 0);\n      }\n    };\n  }(),\n\n  /**\n   * Add or update item with delay support.\n   */\n  renderItems: function renderItems(list, activeKeys, i) {\n    var _this = this;\n\n    var data = this.data;\n    var el = this.el;\n    var itemEl;\n    var item = list[i];\n\n    // If key not defined, use index (e.g., array of strings).\n    var keyValue = data.key ? item[data.key].toString() : item.toString();\n\n    if (this.renderedKeys.indexOf(keyValue) === -1) {\n      // Add.\n      itemEl = this.generateFromTemplate(item, i);\n      el.appendChild(itemEl);\n      this.renderedKeys.push(keyValue);\n    } else {\n      // Update.\n      if (list.length && list[0].constructor === String) {\n        // Update index for simple list.\n        var _keyValue = data.key ? item[data.key].toString() : item.toString();\n        itemEl = el.querySelector('[data-bind-for-value=\"' + _keyValue + '\"]');\n        itemEl.setAttribute('data-bind-for-key', i);\n      } else {\n        var bindForKey = this.getBindForKey(item, i);\n        itemEl = el.querySelector('[data-bind-for-key=\"' + bindForKey + '\"]');\n      }\n      itemEl.emit('bindforupdate', item, false);\n    }\n\n    if (!list[i + 1]) {\n      return;\n    }\n\n    if (this.data.delay) {\n      setTimeout(function () {\n        _this.renderItems(list, activeKeys, i + 1);\n      }, this.data.delay);\n    } else {\n      this.renderItems(list, activeKeys, i + 1);\n    }\n  },\n\n  /**\n   * When items are swapped out, this algorithm will update component values in-place using\n   * bind-item.\n   */\n  onStateUpdateInPlace: function () {\n    var activeKeys = [];\n\n    return function () {\n      var data = this.data;\n      var el = this.el;\n      var list;\n      var key;\n      var keyValue;\n\n      try {\n        list = lib.select(this.system.state, data.in);\n      } catch (e) {\n        console.log(e);\n        throw new Error('[aframe-state-component] Key \\'' + data.in + '\\' not found in state.' + (' #' + el.getAttribute('id') + '[' + this.attrName + ']'));\n      }\n\n      // Calculate keys that should be active.\n      activeKeys.length = 0;\n      for (var i = 0; i < list.length; i++) {\n        var item = list[i];\n        keyValue = data.key ? item[data.key].toString() : item.toString();\n        activeKeys.push(keyValue);\n      }\n\n      // Remove items by pooling. Do before adding.\n      var toRemoveEls = this.getElsToRemove(activeKeys, this.renderedKeys);\n      for (var _i2 = 0; _i2 < toRemoveEls.length; _i2++) {\n        toRemoveEls[_i2].object3D.visible = false;\n        toRemoveEls[_i2].setAttribute('data-bind-for-active', 'false');\n        toRemoveEls[_i2].removeAttribute('data-bind-for-key');\n        toRemoveEls[_i2].removeAttribute('data-bind-for-value');\n        toRemoveEls[_i2].emit('bindfordeactivate', null, false);\n        toRemoveEls[_i2].pause();\n      }\n\n      if (list.length) {\n        this.renderItemsInPlace(list, activeKeys, 0);\n      }\n    };\n  }(),\n\n  /**\n   * Add, takeover, or update item with delay support.\n   */\n  renderItemsInPlace: function renderItemsInPlace(list, activeKeys, i) {\n    var _this2 = this;\n\n    var data = this.data;\n    var el = this.el;\n    var itemEl;\n\n    var item = list[i];\n    var bindForKey = this.getBindForKey(item, i);\n    var keyValue = data.key ? item[data.key].toString() : item.toString();\n\n    // Add item.\n    if (this.renderedKeys.indexOf(keyValue) === -1) {\n      if (!el.querySelector(':scope > [data-bind-for-active=\"false\"]')) {\n        // No items available in pool. Generate new entity.\n        var _itemEl = this.generateFromTemplate(item, i);\n        _itemEl.addEventListener('loaded', function () {\n          _itemEl.emit('bindforupdateinplace', item, false);\n        });\n        el.appendChild(_itemEl);\n      } else {\n        // Take over inactive item.\n        itemEl = el.querySelector('[data-bind-for-active=\"false\"]');\n        itemEl.setAttribute('data-bind-for-key', bindForKey);\n        itemEl.setAttribute('data-bind-for-value', keyValue);\n        itemEl.object3D.visible = true;\n        itemEl.play();\n        itemEl.setAttribute('data-bind-for-active', 'true');\n        itemEl.emit('bindforupdateinplace', item, false);\n      }\n      this.renderedKeys.push(keyValue);\n    } else if (activeKeys.indexOf(keyValue) !== -1) {\n      // Update item.\n      if (list.length && list[0].constructor === String) {\n        // Update index for simple list.\n        itemEl = el.querySelector('[data-bind-for-value=\"' + keyValue + '\"]');\n        itemEl.setAttribute('data-bind-for-key', i);\n      } else {\n        itemEl = el.querySelector('[data-bind-for-key=\"' + bindForKey + '\"]');\n      }\n      itemEl.emit('bindforupdateinplace', item, false);\n    }\n\n    if (!list[i + 1]) {\n      return;\n    }\n\n    if (this.data.delay) {\n      setTimeout(function () {\n        _this2.renderItemsInPlace(list, activeKeys, i + 1);\n      }, this.data.delay);\n    } else {\n      this.renderItemsInPlace(list, activeKeys, i + 1);\n    }\n  },\n\n  /**\n   * Generate entity from template.\n   */\n  generateFromTemplate: function generateFromTemplate(item, i) {\n    var data = this.data;\n\n    this.el.appendChild(this.system.renderTemplate(this.template, item));\n    var newEl = this.el.children[this.el.children.length - 1];;\n\n    // From pool.true\n    if (!item) {\n      newEl.setAttribute('data-bind-for-key', '');\n      newEl.setAttribute('data-bind-for-active', 'false');\n      return newEl;\n    }\n\n    var bindForKey = this.getBindForKey(item, i);\n    newEl.setAttribute('data-bind-for-key', bindForKey);\n    if (!data.key) {\n      newEl.setAttribute('data-bind-for-value', item);\n    }\n\n    // Keep track of pooled and non-pooled entities if updating in place.\n    newEl.setAttribute('data-bind-for-active', 'true');\n    return newEl;\n  },\n\n  /**\n   * Get entities marked for removal.\n   *\n   * @param {array} activeKeys - List of key values that should be active.\n   * @param {array} renderedKeys - List of key values currently rendered.\n   */\n  getElsToRemove: function () {\n    var toRemove = [];\n\n    return function (activeKeys, renderedKeys) {\n      var data = this.data;\n      var el = this.el;\n\n      toRemove.length = 0;\n      for (var i = 0; i < el.children.length; i++) {\n        if (el.children[i].tagName === 'TEMPLATE') {\n          continue;\n        }\n        var key = data.key ? el.children[i].getAttribute('data-bind-for-key') : el.children[i].getAttribute('data-bind-for-value');\n        if (activeKeys.indexOf(key) === -1 && renderedKeys.indexOf(key) !== -1) {\n          toRemove.push(el.children[i]);\n          renderedKeys.splice(renderedKeys.indexOf(key), 1);\n        }\n      }\n      return toRemove;\n    };\n  }(),\n\n  /**\n   * Get value to use as the data-bind-for-key.\n   * For items, will be value specified by `bind-for.key`.\n   * For simple list, will be the index.\n   */\n  getBindForKey: function getBindForKey(item, i) {\n    return this.data.key ? item[this.data.key].toString() : i.toString();\n  },\n\n  /**\n   * Handle state update.\n   */\n  onStateUpdate: function onStateUpdate() {\n    if (this.data.updateInPlace) {\n      this.onStateUpdateInPlace();\n    } else {\n      this.onStateUpdateNaive();\n    }\n  }\n});\n\n/**\n * Handle parsing and update in-place updates under bind-for.\n */\nAFRAME.registerComponent('bind-item', {\n  schema: {\n    type: 'string'\n  },\n\n  multiple: true,\n\n  init: function init() {\n    this.itemData = null;\n    this.keysToWatch = [];\n    this.prevValues = {};\n\n    // Listen to root item for events.\n    var rootEl = this.rootEl = this.el.closest('[data-bind-for-key]');\n    if (!rootEl) {\n      throw new Error('bind-item component must be attached to entity under a bind-for item.');\n    }\n    rootEl.addEventListener('bindforupdateinplace', this.updateInPlace.bind(this));\n    rootEl.addEventListener('bindfordeactivate', this.deactivate.bind(this));\n\n    this.el.sceneEl.systems.state.subscribe(this);\n  },\n\n  update: function update() {\n    this.parseSelector();\n  },\n\n  /**\n   * Run with bind-for tells to via event `bindforupdateinplace`, passing item data.\n   */\n  updateInPlace: function updateInPlace(evt) {\n    var propertyMap = this.propertyMap;\n\n    if (this.rootEl.getAttribute('data-bind-for-active') === 'false') {\n      return;\n    }\n\n    if (evt) {\n      this.itemData = evt.detail;\n    }\n\n    for (var property in propertyMap) {\n      // Get value from item.\n      var value = this.select(this.itemData, propertyMap[property]);\n\n      // Diff against previous value.\n      if (value === this.prevValues[property]) {\n        continue;\n      }\n\n      // Update.\n      AFRAME.utils.entity.setComponentProperty(this.el, property, value);\n\n      this.prevValues[property] = value;\n    }\n  },\n\n  onStateUpdate: function onStateUpdate() {\n    this.updateInPlace();\n  },\n\n  select: function select(itemData, selector) {\n    return lib.select(this.el.sceneEl.systems.state.state, selector, itemData);\n  },\n\n  deactivate: function deactivate() {\n    this.prevValues = {};\n  },\n\n  parseSelector: function parseSelector() {\n    var propertyMap = this.propertyMap = {};\n    this.keysToWatch.length = 0;\n\n    var componentName = lib.split(this.id, '__')[0];\n\n    // Different parsing for multi-prop components.\n    if (componentName in AFRAME.components && !AFRAME.components[componentName].isSingleProp) {\n      var propertySplitList = lib.split(this.data, ';');\n      for (var i = 0; i < propertySplitList.length; i++) {\n        var propertySplit = lib.split(propertySplitList[i], ':');\n        propertyMap[this.id + '.' + propertySplit[0].trim()] = propertySplit[1].trim();\n        lib.parseKeysToWatch(this.keysToWatch, propertySplit[1].trim(), true);\n      }\n      return;\n    }\n\n    propertyMap[this.id] = this.data;\n    lib.parseKeysToWatch(this.keysToWatch, this.data, true);\n  }\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Computes the difference between two objects with ability to ignore keys.\n *\n * @param {object} a - First object to compare (e.g., oldData).\n * @param {object} b - Second object to compare (e.g., newData).\n * @returns {object}\n *   Difference object where set of keys note which values were not equal, and values are\n *   `b`'s values.\n */\nmodule.exports = function () {\n  var keys = [];\n\n  return function (a, b, targetObject, ignoreKeys) {\n    var aVal;\n    var bVal;\n    var bKey;\n    var diff;\n    var key;\n    var i;\n    var isComparingObjects;\n\n    diff = targetObject || {};\n\n    // Collect A keys.\n    keys.length = 0;\n    for (key in a) {\n      keys.push(key);\n    }\n\n    if (!b) {\n      return diff;\n    }\n\n    // Collect B keys.\n    for (bKey in b) {\n      if (keys.indexOf(bKey) === -1) {\n        keys.push(bKey);\n      }\n    }\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n\n      // Ignore specified keys.\n      if (ignoreKeys && ignoreKeys.indexOf(key) !== -1) {\n        continue;\n      }\n\n      aVal = a[key];\n      bVal = b[key];\n      isComparingObjects = aVal && bVal && aVal.constructor === Object && bVal.constructor === Object;\n      if (isComparingObjects && !AFRAME.utils.deepEqual(aVal, bVal) || !isComparingObjects && aVal !== bVal) {\n        diff[key] = bVal;\n      }\n    }\n    return diff;\n  };\n}();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar fns = ['push', 'pop', 'shift', 'unshift', 'splice'];\n\nfunction wrapArray(arr) {\n  var i;\n  if (arr.__wrapped) {\n    return;\n  }\n  for (i = 0; i < fns.length; i++) {\n    makeCallDirty(arr, fns[i]);\n  }\n  arr.__wrapped = true;\n}\nmodule.exports.wrapArray = wrapArray;\n\nfunction makeCallDirty(arr, fn) {\n  var originalFn = arr[fn];\n  arr[fn] = function () {\n    originalFn.apply(arr, arguments);\n    arr.__dirty = true;\n  };\n}\n\n/***/ })\n/******/ ]);\n});","AFRAME.registerComponent(\"hammer-logic\", {\n  init: function () {\n    let crabs = [];\n\n    this.el.addEventListener(\"crabs_appear\", function () {\n      crabs = Array.prototype.slice.call(document.querySelectorAll(\".crab\"));\n    });\n    this.el.addEventListener(\"animationStart\", function () {\n      crabs.map(function (crab) {\n        crab.emit(\"dontDie\");\n      });\n    });\n    this.el.addEventListener(\"animationEnd\", function () {\n      crabs.map(function (crab) {\n        crab.emit(\"die\");\n      });\n    });\n  },\n});\n","import \"aframe-state-component\";\nAFRAME.registerState({\n  initialState: {\n    score: 2,\n  },\n\n  handlers: {\n    decreaseScore: function (state, action) {\n      state.score -= action.points;\n    },\n\n    increaseScore: function (state, action) {\n      state.score += action.points;\n    },\n  },\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// hammer-logic component\nimport \"./components/hammer-logic\";\n\n// state hndler\nimport \"./components/state\";\n"],"names":["AFRAME","registerComponent","init","crabs","el","addEventListener","Array","prototype","slice","call","document","querySelectorAll","map","crab","emit","registerState","initialState","score","handlers","decreaseScore","state","action","points","increaseScore"],"sourceRoot":""}